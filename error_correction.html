<html>
  <head>
  	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,400">  <!-- Google web font "Open Sans" -->
  	<link rel="stylesheet" href="css/fontawesome-all.min.css"> <!-- Icons -->
  	<link rel="stylesheet" href="css/bootstrap.min.css">
  	<link rel="stylesheet" href="css/tooplate-style.css">
  	<link rel="stylesheet" href="css/styles.css">

  	<title>Корекция при грешки</title>

    <style>
      #fig-1 {
        width: 75%;
      }
    </style>

    <link rel="icon" href="img/icon.png">
  </head>
  <body>
  	<div class="row">
      <section class="col-xl-2 col-lg-2 col-md-1 col-sm-1">
        <div id="direct-home"><a href="index.html"><i class="fas fa-home"></i>Начало</a></div>
      </section>
  		<section id="pageContent" class="col-xl-8 col-lg-8 col-md-10 col-sm-10">
        <p>&emsp;Контролът на грешките включва и механизъм за коригиране на грешки, след като те бъдат открити. Откриването и коригирането на грешки в TCP се постига чрез използването на три прости инструмента: checksum, acknowledgement и изчакване.</p>
        <p>&emsp;Checksum: Всеки сегмент включва поле за контролна сума, което се използва за проверка за повреден сегмент. Ако сегментът е повреден, той се отхвърля от целевия TCP и се счита за изгубен. TCP използва 16-битова контролна сума, която е задължителна във всеки сегмент.</p>
        <p>&emsp;Acknowledgement: TCP използва потвърждения, за да потвърди получаването на сегменти от данни. Контролните сегменти, които не носят данни, но консумират пореден номер, също се потвърждават.</p>
        <p>&emsp;Препредаване: Сърцевината на механизма за контрол на грешките е препредаването на сегменти. Когато даден сегмент е повреден, загубен или забавен, той се препредава. В съвременните реализации сегментът се препредава два пъти: когато изтече таймерът за повторно предаване или когато подателят получава три дублирани ACK. Имайте предвид, че не се извършва повторно предаване за сегменти, които не консумират поредни номера като ACK.</p>
        <p>&emsp;Препредаване след RTO [retransmission time-out]: TCP поддържа таймер за изчакване за препредаване (RTO) за всички неизпълнени (изпратени, но не потвърдени) сегменти. Когато таймерът изтече, най-ранният неизпълнен сегмент се препредава, въпреки че липсата на получен ACK може да се дължи на забавен сегмент, забавен ACK или загубено потвърждение.</p>

        <span class="note"><i class="far fa-sticky-note note-icon"></i><b>Забележка:</b><br/>&emsp;Out-of-Order Segments: Когато даден сегмент се забави, загуби или изхвърли, сегментите, следващи този сегмент, пристигат извън ред. Първоначално TCP е проектиран да „изхвърля“ всички неподходящи сегменти, което води до повторно предаване на липсващия сегмент и следващите сегменти. Повечето имплементации днес не отхвърлят неподредените сегменти. Те ги съхраняват временно (в буфер) и ги маркират като сегменти, които не са в ред, докато липсващият сегмент пристигне. TCP гарантира, че данните се предават в процеса по ред.</p></span>

          <div id="fig-1" class="figure">
            <img src="img/retry.png" />
            <span>Фиг. 1 Коригиране на грешки при липсса на потвърждение на пакет.</span>
          </div>

      </section>
      <section class="col-xl-2 col-lg-2 col-md-1 col-sm-1"></section>
  	</div> <!-- End of row div -->


  	<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
  	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
